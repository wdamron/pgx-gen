package pgxgen

import (
	"fmt"
	"go/format"

	"github.com/wdamron/astx"
)

const DRIVER = "github.com/wdamron/pgx"

type File struct {
	Pkg, Driver string
	Structs     []Struct
	File        *astx.File
}

func Gen(f *astx.File) ([]byte, error) {
	structs := make([]Struct, 0, len(f.Structs))
	for _, s := range f.Structs {
		structs = append(structs, Struct{s})
	}
	file := File{
		Pkg:     f.Package,
		Driver:  DRIVER,
		Structs: structs,
		File:    f,
	}
	out, err := write(file)
	if err != nil {
		return nil, err
	}

	return format.Source(out)
}

func write(f File) ([]byte, error) {
	const headerTemplate = `
package %s

// Generated by pgxgen (see %s)

`

	const importsTemplate = `
import (
	"errors"
	"encoding/hex"
	
	"%s"
)

`

	const tableTypeTemplate = `
type %sTableType struct {
	Decoders    [%d]%sColumnDecoder
	ColumnNames [%d]string
}

`

	const decoderTemplate = `// Decode column %s::%s into (*%s).%s
func(v *%s, vr *pgx.ValueReader) error {
	%s
},
`

	const renamerTemplate = `
// Rename (alias) columns before running or preparing queries, for faster
// look-ups during decoding
func (t *%sTableType) Rename(cols ...string) ([]string, error) {
	aliases := []string{}
	// If no columns are specified, rename all columns:
	if len(cols) == 0 {
		%s
	}
	for _, name := range cols {
		switch name {
		%s
		}
	}
	return aliases, nil
}

`

	const rowDecoderTemplate = `
func (v *%s) DecodeRow(r *pgx.Rows) error {
	for {
		vr, ok := r.NextColumn()
		if !ok {
			if vr != nil && vr.Err() {
				return vr.Err()
			}
			break
		}
		colname := vr.Type().Name
		// Fast path (renamed columns):
		if len(colname) == 4 && colname[:2] == "__" {
			b, err := hex.DecodeString(colname[2:4])
			if err != nil {
				return err
			}
			index := int(b[0])
			dec := %sTable.Decoders[index]
			if err = dec(v, vr); err != nil {
				return err
			}
			continue
		}
		// Slow path:
		var dec %sColumnDecoder
		switch colname {
		%s
		}
		if err := dec(v, vr); err != nil {
			return err
		}
	}
	return nil
}

`

	out := fmt.Sprintf(headerTemplate, f.Pkg, f.File.Path)
	hasColumns := false
	for _, s := range f.Structs {
		cols := s.GetColumns()
		count := len(cols)
		if count == 0 {
			continue
		}
		if !hasColumns {
			out += fmt.Sprintf(importsTemplate, f.Driver)
			hasColumns = true
		}
		name := s.StructName()
		out += fmt.Sprintf("type %sColumnDecoder func(*%s, *pgx.ValueReader) error\n\n", name, name)
		out += fmt.Sprintf(tableTypeTemplate, name, count, name, count)
		defaultRenamerBody := GenDefaultRenamerBody(cols)
		renamerBody := GenRenamerCases(&s, cols)
		out += fmt.Sprintf(renamerTemplate, name, defaultRenamerBody, renamerBody)

		out += fmt.Sprintf("var %sTable = %sTableType{\n", name, name)
		var decoders, columnNames string
		for _, c := range cols {
			body, err := GenColumnDecoderBody(&c)
			if err != nil {
				return nil, err
			}
			decoders += fmt.Sprintf(decoderTemplate, c.Name, c.Type, name, c.StructField.Name, name, body)
			columnNames += fmt.Sprintf("\"%s\",\n", c.Name)
		}

		out += fmt.Sprintf("Decoders: [%d]%sColumnDecoder{\n%s},\n", count, name, decoders)
		out += fmt.Sprintf("ColumnNames: [%d]string{\n%s},\n}\n\n", count, columnNames)

		rowDecoderBody := GenRowDecoderCases(&s, cols)
		out += fmt.Sprintf(rowDecoderTemplate, name, name, name, rowDecoderBody)
	}
	return []byte(out), nil
}
