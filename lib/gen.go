package pgxgen

import (
	"encoding/hex"
	"fmt"
	"go/format"

	"github.com/wdamron/astx"
)

const DRIVER = "github.com/wdamron/pgx"

type File struct {
	Pkg, Driver string
	Structs     []Struct
	File        *astx.File
}

func NewFile(f *astx.File) *File {
	structs := make([]Struct, 0, len(f.Structs))
	for _, astStruct := range f.Structs {
		s := NewStruct(&astStruct)
		structs = append(structs, *s)
	}
	return &File{
		Pkg:     f.Package,
		Driver:  DRIVER,
		Structs: structs,
		File:    f,
	}
}

func (f *File) Gen() ([]byte, error) {
	out, err := f.gen()
	if err != nil {
		return nil, err
	}

	return format.Source(out)
}

func (f *File) gen() ([]byte, error) {
	// Always write the header (package name, pgxgen comment):
	out := genHeader(f)

	wroteImports := false
	for _, s := range f.Structs {
		cols := s.Columns
		count := len(cols)
		if count == 0 {
			continue
		}
		// include import statement, if not already included:
		if !wroteImports {
			out += genImports(f)
			wroteImports = true
		}

		// generate type def for {struct-name}TableType struct:
		out += genTableType(&s)

		// generate var def for {struct-name}Table:
		table, err := genTable(&s)
		if err != nil {
			return nil, err
		}
		out += table

		// generate method def for {struct-name}TableType.Index:
		out += genIndexMethod(&s)

		// generate method def for {struct-name}TableType.Indexes:
		out += genIndexesMethod(&s)

		// generate method def for ({struct-name})TableType.Alias:
		out += genAliasMethod(&s)

		// generate method def for ({struct-name})TableType.AliasAll:
		out += genAliasAllMethod(&s)

		// generate method def for {struct-name}.DecodeRow:
		out += genRowDecoder(&s)

		// generate type def for {struct-name}ParamsEncoder struct:
		out += genParamsEncoderType(&s)

		// generate method def for ({struct-name})TableType.Encoder:
		out += genEncoderFactory(&s)

		// generate method def for {struct-name}ParamsEncoder.Bind:
		out += genBindVal(&s)

		// generate method def for {struct-name}ParamsEncoder.EncodeParamFormats:
		out += genEncodeParamFormats(&s)

		// generate method def for {struct-name}ParamsEncoder.EncodeParams:
		out += genEncodeParams(&s)
	}

	return []byte(out), nil
}

const headerFmt = `
package %s

// Generated by pgxgen (see %s)

`

func genHeader(f *File) string {
	return fmt.Sprintf(headerFmt, f.Pkg, f.File.Path)
}

const importsFmt = `
import (
	"errors"
	"encoding/hex"
	
	"%s"
)

`

func genImports(f *File) string {
	return fmt.Sprintf(importsFmt, f.Driver)
}

const tableTypeFmt = `
// %sTableType is the type of %sTable, which describes the table
// corresponding with type %s
type %sTableType struct {
	// Encoders can be used to encode a single param value from type %s
	// into a write buffer, as part of a raw query
	Encoders    [%d]func(*%s, *pgx.WriteBuf) error
	// Decoders can be used to decode a single column value from a
	// pgx.ValueReader into type %s
	Decoders    [%d]func(*%s, *pgx.ValueReader) error
	// Names contains an ordered list of column names
	Names [%d]string
	// Types contains an ordered list of column types
	Types [%d]string
	// Aliases contains an ordered list of column names aliased as hex-encoded
	// indexes, for faster look-ups during decoding
	Aliases     [%d]string
	// Formats contains an ordered list of column format codes (text=0, binary=1)
	Formats     [%d]int
	// Oids contains an ordered list of column oid codes (corresponding with
	// Postgres types)
	Oids        [%d]pgx.Oid
}

`

// generate type def for {struct-name}TableType struct
func genTableType(s *Struct) string {
	cols := len(s.Columns)
	return fmt.Sprintf(tableTypeFmt, s.Name, s.Name, s.Name, s.Name, s.Name, cols, s.Name, s.Name, cols, s.Name, cols, cols, cols, cols, cols)
}

// generate method def for ({struct-name})TableType.Index
func genIndexMethod(s *Struct) string {
	out := fmt.Sprintf("// Index returns the index of the column in %sTable with the given name.\n", s.Name)
	out += "// If no matching column is found, the returned index will be -1.\n"
	out += fmt.Sprintf("func (t *%sTableType) Index(colname string) int {\n", s.Name)
	out += "switch colname {\n"

	for i, c := range s.Columns {
		out += fmt.Sprintf("case \"%s\": return %d\n", c.Name, i)
	}
	out += "}\nreturn -1\n}\n\n"
	return out
}

const indexesMethodFmt = `
// Indexes returns a slice of indexes of the given columns in %sTable
// with the given name. If any of the columns are not found, an error will be
// returned and the returned slice of indexes will be nil.
func (t *%sTableType) Indexes(colnames ...string) ([]int, error) {
	indexes := make([]int, len(colnames))
	for i, colname := range colnames {
		index := t.Index(colname)
		if index < 0 {
			return nil, errors.New("column " + colname + " not found in %sTable")
		}
		indexes[i] = index
	}
	return indexes, nil
}

`

// generate method def for ({struct-name})TableType.Indexes
func genIndexesMethod(s *Struct) string {
	return fmt.Sprintf(indexesMethodFmt, s.Name, s.Name, s.Name)
}

const aliasMethodFmt = `
// Aliases aliases column names as hex-encoded indexes, for faster look-ups during
// decoding. If no column names are provided, all columns will be aliased, in
// which case AliasAll may be a faster alternative.
func (t *%sTableType) Aliases(colnames ...string) ([]string, error) {
	aliases := []string{}
	// If no columns are specified, alias all columns:
	if len(cols) == 0 {
		return %sTable.Aliases[:%d], nil
	}
	indexes, err := %sTable.Indexes(colnames...)
	if err != nil {
		return nil, err
	}
	for _, index := range indexes {
		aliases = append(aliases, %sTable.Aliases[index])
	}
	return aliases, nil
}

`

// generate method def for ({struct-name})TableType.Alias
func genAliasMethod(s *Struct) string {
	return fmt.Sprintf(aliasMethodFmt, s.Name, s.Name, len(s.Columns), s.Name, s.Name)
}

// generate method def for ({struct-name})TableType.AliasAll
func genAliasAllMethod(s *Struct) string {
	out := "// AliasAll aliases column names as hex-encoded indexes, for faster look-ups\n"
	out += "// during decoding\n"
	out += fmt.Sprintf("func (t *%sTableType) AliasAll() string {\n", s.Name)
	out += "return \""

	lastIdx := len(s.Columns) - 1
	for i, c := range s.Columns {
		// 256 columns are supported, for now:
		hexIdx := hex.EncodeToString([]byte{byte(i)})
		if len(hexIdx) == 1 {
			hexIdx = "0" + hexIdx
		}
		shortName := "__" + hexIdx
		out += fmt.Sprintf("%s as %s::%s", c.Name, shortName, c.Type)
		if i != lastIdx {
			out += ", "
		}
	}

	return out + "\"\n}\n\n"
}

// generate var def for {struct-name}Table
func genTable(s *Struct) (string, error) {
	out := fmt.Sprintf("// %sTable describes the table corresponding with type %s\n", s.Name, s.Name)
	out += fmt.Sprintf("var %sTable = %sTableType{\n", s.Name, s.Name)
	// include ordered list of param-encoder funcs:
	encoders, err := genEncoderArray(s)
	if err != nil {
		return "", err
	}
	out += encoders
	// include ordered list of column-decoder funcs:
	decoders, err := genColDecoderArray(s)
	if err != nil {
		return "", err
	}
	out += decoders
	// include ordered list of column names:
	out += genColNameArray(s)
	// include ordered list of column types:
	out += genColTypeArray(s)
	// include ordered list of column aliases:
	out += genAliasArray(s)
	// include ordered list of column format codes:
	out += genFormatArray(s)
	// include ordered list of column oids:
	out += genOidArray(s)

	return out + "}\n\n", nil
}

// include ordered list of param-encoder funcs
func genEncoderArray(s *Struct) (string, error) {
	out := fmt.Sprintf("Encoders: [%d]func(*%s, *pgx.WriteBuf) error {\n", len(s.Columns), s.Name)
	for _, c := range s.Columns {
		f := c.StructField
		if Encoders[f.Type] == nil {
			return "", fmt.Errorf("no column decoder available for field: %s", f.Name)
		}
		op := Encoders[f.Type][c.Type]
		if op == Op(0) {
			return "", fmt.Errorf("no column decoder available for field: %s", f.Name)
		}
		oidName := OidNames[c.Type]
		if oidName == "" {
			return "", fmt.Errorf("no column decoder available for field: %s", f.Name)
		}

		out += fmt.Sprintf("// Encode (*%s).%s as %s\n", s.Name, c.StructField.Name, c.Type)
		out += fmt.Sprintf("func(v *%s, wbuf *pgx.WriteBuf) error {\n", s.Name)
		if op.CustomEncode() {
			if c.Type == "hstore" {
				oidName = "Oid(0)"
			} else {
				oidName += "Oid"
			}
			out += fmt.Sprintf("v.%s.Encode(wbuf, pgx.%s)\n", f.Name, oidName)
		} else {
			var castPrefix, castSuffix string
			if op.MaskCast() != Op(0) {
				castPrefix, castSuffix = op.FormatCast()+"(", ")"
			}
			deref := ""
			if op.DerefPass() {
				deref = "*"
			}
			out += fmt.Sprintf("wbuf.Encode%s(%s%sv.%s%s)\n", oidName, castPrefix, deref, c.StructField.Name, castSuffix)
		}
		out += "return nil\n},\n"
	}
	return out + "},\n", nil
}

// include ordered list of column-decoder funcs
func genColDecoderArray(s *Struct) (string, error) {
	count := len(s.Columns)
	out := fmt.Sprintf("Decoders: [%d]func(*%s, *pgx.ValueReader) error{\n", count, s.Name)
	for _, c := range s.Columns {
		decoder, err := genColumnDecoder(s, &c)
		if err != nil {
			return "", err
		}
		out += decoder
	}
	return out + "},\n", nil
}

// generate column-decoder func
func genColumnDecoder(s *Struct, c *Column) (string, error) {
	f := c.StructField
	coltype := c.Type
	if coltype == "" {
		return "", fmt.Errorf("no column type found in field: %s", f.Name)
	}
	if Decoders[coltype] == nil {
		return "", fmt.Errorf("no column decoder available for field: %s", f.Name)
	}
	op := Decoders[coltype][f.Type]
	if op == Op(0) {
		return "", fmt.Errorf("no column decoder available for field: %s (coltype=%s, fieldtype=%s)", f.Name, c.Type, f.Type)
	}
	oidName := OidNames[coltype]
	if oidName == "" {
		return "", fmt.Errorf("no column oid for field: %s", f.Name)
	}
	// TODO(wd): check overflow, when necessary
	out := fmt.Sprintf("// Decode column %s::%s into (*%s).%s\n", c.Name, coltype, s.Name, f.Name)
	out += fmt.Sprintf("func(v *%s, vr *pgx.ValueReader) error {\n", s.Name)
	if op.CustomScan() {
		out += fmt.Sprintf("if err := v.%s.Scan(vr); err != nil {\nreturn err\n}\n", f.Name)
	} else {
		var prefix, suffix string
		if op.MaskCast() != Op(0) {
			prefix, suffix = op.FormatCast()+"(", ")"
		}
		out += fmt.Sprintf("x := %svr.Decode%s()%s\n", prefix, oidName, suffix)
		out += "if vr.Err() != nil {\nreturn vr.Err()\n}\n"
		if op.PtrAssign() {
			out += "*"
		}
		out += fmt.Sprintf("v.%s = x\n", f.Name)
	}
	out += "return nil\n},\n"

	return out, nil
}

// include ordered list of column names
func genColNameArray(s *Struct) string {
	out := fmt.Sprintf("Names: [%d]string{\n", len(s.Columns))
	for _, c := range s.Columns {
		out += fmt.Sprintf("\"%s\",\n", c.Name)
	}
	return out + "},\n"
}

// include ordered list of column types
func genColTypeArray(s *Struct) string {
	out := fmt.Sprintf("Types: [%d]string{\n", len(s.Columns))
	for _, c := range s.Columns {
		out += fmt.Sprintf("\"%s\",\n", c.Type)
	}
	return out + "},\n"
}

// include ordered list of column aliases
func genAliasArray(s *Struct) string {
	out := "// Aliases contains an ordered list of column names aliased as hex-encoded\n"
	out += "// indexes, for faster look-ups during decoding\n"
	out += fmt.Sprintf("Aliases: [%d]string{\n", len(s.Columns))
	for i, col := range s.Columns {
		// 256 columns are supported, for now:
		hexIdx := hex.EncodeToString([]byte{byte(i)})
		if len(hexIdx) == 1 {
			hexIdx = "0" + hexIdx
		}
		shortName := "__" + hexIdx
		out += fmt.Sprintf("\"%s as %s::%s\",\n", col.Name, shortName, col.Type)
	}
	return out + "},\n"
}

// include ordered list of column oids
func genOidArray(s *Struct) string {
	out := fmt.Sprintf("Oids: [%d]pgx.Oid{\n", len(s.Columns))
	for _, c := range s.Columns {
		var oidName string
		if c.Type == "hstore" {
			oidName = "Oid(0)"
		} else {
			oidName = OidNames[c.Type] + "Oid"
		}
		out += fmt.Sprintf("pgx.%s,\n", oidName)
	}
	return out + "},\n"
}

// include ordered list of column format codes (text=0, binary=1)
func genFormatArray(s *Struct) string {
	out := fmt.Sprintf("Formats: [%d]int{", len(s.Columns))
	for i, c := range s.Columns {
		if BinaryFmtOids[OidNames[c.Type]] {
			out += "1"
		} else {
			out += "0"
		}
		if i != len(s.Columns)-1 {
			out += ", "
		}
	}
	return out + "},\n"
}

const rowDecoderFmt = `
// DecodeRow decodes a SQL row into type %s.
// If an error is returned, the caller should call Rows.Close()
func (v *%s) DecodeRow(r *pgx.Rows) error {
	for _ = range r.FieldDescriptions() {
		vr, ok := r.NextColumn()
		if !ok {
			if vr != nil && vr.Err() {
				return vr.Err()
			}
			break
		}
		colname := vr.Type().Name

		// Fast path (aliased columns):
		if len(colname) == 4 && colname[:2] == "__" {
			b, err := hex.DecodeString(colname[2:4])
			if err != nil {
				return err
			}
			index := int(b[0])
			if index < 0 || index > len(%sTable.Decoders) - 1 {
				return errors.New("column decoder index out of range")
			}
			dec := %sTable.Decoders[index]
			if err = dec(v, vr); err != nil {
				return err
			}
			continue
		}
		
		// Slow path:
		index := %sTable.Index(colname)
		if index < 0  || index > len(%sTable.Decoders) - 1 {
			return errors.New("column decoder for " + colname + " not found in %sTable")
		}
		if err := %sTable.Decoders[index](v, vr); err != nil {
			return err
		}
	}
	return nil
}

`

// generate method def for {struct-name}.DecodeRow
func genRowDecoder(s *Struct) string {
	return fmt.Sprintf(rowDecoderFmt, s.Name, s.Name, s.Name, s.Name, s.Name, s.Name, s.Name, s.Name)
}

const paramsEncoderFmt = `
// %sParamsEncoder encodes parameter formats and values for a prepared statement
// to a buffer, and implements pgx.ParamsEncoder
type %sParamsEncoder struct {
	Indexes       []int
	Formats       []int
	ValueEncoders []func(v *%s, wbuf *pgx.WriteBuf)
	v *%s
}
`

// generate type def for {struct-name}ParamsEncoder struct
func genParamsEncoderType(s *Struct) string {
	return fmt.Sprintf(paramsEncoderFmt, s.Name, s.Name, s.Name, s.Name)
}

const newEncoderFmt = `
// Encoder creates an unbound instance of type %sParamsEncoder
// for the columns/fields named by colnames
func (t *%sTableType) Encoder(colnames ...string) (*%sParamsEncoder, error) {
	formats := make([]int, len(colnames))
	encoders := make([]func(*%s, *pgx.WriteBuf), len(colnames))

	indexes, err := %sTable.Indexes(colnames...)
	if err != nil {
		return nil, err
	}
	for i, index := range indexes {
		if index < 0  || index > len(%sTable.Formats) - 1 {
			return nil, errors.New("column format index out of range")
		}
		formats[i] = %sTable.Formats[index]
		if index < 0  || index > len(%sTable.Encoders) - 1 {
			return nil, errors.New("column encoder for " + colnames[i] + " not found in %sTable")
		}
		encoders[i] = %sTable.Encoders[index]
	}
	

	pe := &%sParamsEncoder{
		Indexes: indexes,
		Formats: formats,
		ValueEncoders: encoders,
	}
	return pe, nil
}
`

// generate method def for {struct-name}TableType.Encoder
func genEncoderFactory(s *Struct) string {
	return fmt.Sprintf(newEncoderFmt, s.Name, s.Name, s.Name, s.Name, s.Name, s.Name, s.Name, s.Name, s.Name, s.Name, s.Name)
}

const bindValFmt = `
// Bind binds value v to pe, returning a pgx.ParamsEncoder for use within raw queries
func (pe %sParamsEncoder) Bind(v *%s) pgx.ParamsEncoder {
	return &%sParamsEncoder{
		Indexes: pe.Indexes,
		Formats: pe.Formats,
		ValueEncoders: pe.ValueEncoders,
		v: v,
	}
}
`

// generate method def for {struct-name}ParamsEncoder.Bind
func genBindVal(s *Struct) string {
	return fmt.Sprintf(bindValFmt, s.Name, s.Name, s.Name)
}

const encodeParamFormatsFmt = `
// EncodeParamFormats encodes param formats into wbuf, as part of a raw query
// (%sParamsEncoder should implement pgx.ParamsEncoder)
func (pe *%sParamsEncoder) EncodeParamFormats(ps *pgx.PreparedStatement, wbuf *pgx.WriteBuf) error {
	if len(ps.ParameterOids) != len(pe.Formats) {
		return errors.New("param count of encoder and prepared statement do not match")
	}
	for i, oid := range ps.ParameterOids {
		foundOid := %sTable.Oids[pe.Indexes[i]]
		if oid != foundOid && foundOid != pgx.Oid(0) {
			return errors.New("param oids of encoder and prepared statement do not match")
		}
		wbuf.WriteInt16(int16(pe.Formats[i]))
	}
	return nil
}

`

// generate method def for {struct-name}ParamsEncoder.EncodeParamFormats
func genEncodeParamFormats(s *Struct) string {
	return fmt.Sprintf(encodeParamFormatsFmt, s.Name, s.Name, s.Name)
}

const encodeParamsFmt = `
// EncodeParams encodes the param values into wbuf, as part of a raw query
// (%sParamsEncoder should implement pgx.ParamsEncoder)
func (pe *%sParamsEncoder) EncodeParams(ps *pgx.PreparedStatement, wbuf *pgx.WriteBuf) error {
	for _, enc := range pe.ValueEncoders {
		enc(pe.v, wbuf)
	}
	return nil
}
`

// generate method def for {struct-name}ParamsEncoder.EncodeParams
func genEncodeParams(s *Struct) string {
	return fmt.Sprintf(encodeParamsFmt, s.Name, s.Name)
}
