package pgxgen

import (
	"encoding/hex"
	"fmt"
	"go/format"

	"github.com/wdamron/astx"
)

const DRIVER = "github.com/wdamron/pgx"
const PGTYPES_PKG = "github.com/wdamron/pgx-gen/pgtypes"
const UUID_PKG = "github.com/satori/go.uuid"

// type File holds information extracted from a Go source file
type File struct {
	Pkg, Driver string
	Structs     []Struct
	File        *astx.File
}

// NewFile extracts information from f into a new File.
func NewFile(f *astx.File) *File {
	structs := make([]Struct, 0, len(f.Structs))
	for _, astStruct := range f.Structs {
		s := NewStruct(&astStruct)
		structs = append(structs, *s)
	}
	return &File{
		Pkg:     f.Package,
		Driver:  DRIVER,
		Structs: structs,
		File:    f,
	}
}

// Gen generates and formats code for f, returning bytes or nil if an error has
// occurred
func (f *File) Gen() ([]byte, error) {
	out, err := f.gen()
	if err != nil {
		return nil, err
	}
	return format.Source(out)
}

func (f *File) gen() ([]byte, error) {
	// Always write the header (package name, pgxgen comment):
	out := genHeader(f)

	uuidImported := false
	uuidPkg := fmt.Sprintf(`"%s"`, UUID_PKG)
	for _, imp := range f.File.Imports {
		if imp.Path == uuidPkg {
			uuidImported = true
			break
		}
	}

	// stdImports/otherImports contain mappings from paths to names for imports:
	var stdImports, otherImports = make(map[string]string, 0), make(map[string]string, 0)
	var body string
	for _, s := range f.Structs {
		cols := s.Columns
		count := len(cols)
		if count == 0 {
			continue
		}

		// ensure std packages are imported when columns are present:
		stdImports["errors"] = ""
		stdImports["encoding/hex"] = ""
		// ensure driver is imported when columns are present:
		otherImports[f.Driver] = ""
		// ensure pgtypes is imported when columns are present:
		otherImports[PGTYPES_PKG] = ""

		for _, c := range cols {
			switch c.Type {
			case "uuid":
				ftype := c.StructField.Type
				if (ftype == "uuid.UUID" || ftype == "*uuid.UUID") && !uuidImported {
					return nil, fmt.Errorf("package %s must be imported to use uuid column data types\n(see %s)", uuidPkg, f.File.AbsPath)
				}
				otherImports[UUID_PKG] = ""
			case "json":
				switch c.StructField.Type {
				// include json package when encoding/decoding Go types:
				default:
					stdImports["encoding/json"] = ""
				// json is not encoded/decoded for string and []byte types:
				case "string", "*string", "[]byte", "*[]byte":
				}
			}
		}

		// generate type def for {struct-name}TableType struct:
		body += genTableType(&s)

		// generate var def for {struct-name}Table:
		table, err := genTable(&s)
		if err != nil {
			return nil, err
		}
		body += table

		// generate method def for {struct-name}TableType.Index:
		body += genIndexMethod(&s)

		// generate method def for {struct-name}TableType.Indexes:
		body += genIndexesMethod(&s)

		// generate method def for ({struct-name})TableType.Alias:
		body += genAliasMethod(&s)

		// generate method def for ({struct-name})TableType.AliasAll:
		body += genAliasAllMethod(&s)

		// generate method def for {struct-name}.DecodeRow:
		body += genRowDecoder(&s)

		// generate type def for {struct-name}ParamsEncoder struct:
		body += genParamsEncoderType(&s)

		// generate method def for ({struct-name})TableType.Encoder:
		body += genEncoderCreator(&s)

		// generate method def for {struct-name}ParamsEncoder.Bind:
		body += genBindVal(&s)
	}

	out += genImports(f, stdImports, otherImports)
	out += body

	return []byte(out), nil
}

const headerFmt = `
package %s

// Generated by pgxgen (see %s)

`

func genHeader(f *File) string {
	return fmt.Sprintf(headerFmt, f.Pkg, f.File.Path)
}

func genImports(f *File, stdImports, otherImports map[string]string) string {
	if len(stdImports) == 0 && len(otherImports) == 0 {
		return ""
	}
	out := "import (\n"
	for path, _ := range stdImports {
		out += fmt.Sprintf("\"%s\"\n", path)
	}
	if len(otherImports) != 0 {
		out += "\n"
	}
	for path, name := range otherImports {
		if name != "" {
			out += name + " "
		}
		out += fmt.Sprintf("\"%s\"\n", path)
	}
	out += ")"
	return out
}

const tableTypeFmt = `
// %sTableType is the type of %sTable, which describes the table
// corresponding with type %s
type %sTableType struct {
	// UnboundEncoders are used by %sParamsEncoder.Bind to bind
	// query/statement parameters from a value of type %s
	UnboundEncoders    [%d]func(*%s) pgx.Encoder
	// Decoders can be used to decode a single column value from a
	// pgx.ValueReader into type %s
	Decoders    [%d]func(*%s, *pgx.ValueReader) error
	// Names contains an ordered list of column names
	Names [%d]string
	// Types contains an ordered list of column types
	Types [%d]string
	// Aliases contains an ordered list of column names aliased as hex-encoded
	// indexes, for faster look-ups during decoding
	Aliases     [%d]string
	// Formats contains an ordered list of column format codes (text=0, binary=1)
	Formats     [%d]int
	// Oids contains an ordered list of column oid codes (corresponding with
	// Postgres types)
	Oids        [%d]pgx.Oid
}

`

// generate type def for {struct-name}TableType struct
func genTableType(s *Struct) string {
	cols := len(s.Columns)
	return fmt.Sprintf(tableTypeFmt, s.Name, s.Name, s.Name, s.Name, s.Name, s.Name, cols, s.Name, s.Name, cols, s.Name, cols, cols, cols, cols, cols)
}

// generate method def for ({struct-name})TableType.Index
func genIndexMethod(s *Struct) string {
	out := fmt.Sprintf("// Index returns the index of the column in %sTable with the given name.\n", s.Name)
	out += "// If no matching column is found, the returned index will be -1.\n"
	out += fmt.Sprintf("func (t *%sTableType) Index(colname string) int {\n", s.Name)
	out += "switch colname {\n"

	for i, c := range s.Columns {
		out += fmt.Sprintf("case \"%s\": return %d\n", c.Name, i)
	}
	out += "}\nreturn -1\n}\n\n"
	return out
}

const indexesMethodFmt = `
// Indexes returns a slice of indexes of the given columns in %sTable
// with the given name. If any of the columns are not found, an error will be
// returned and the returned slice of indexes will be nil.
func (t *%sTableType) Indexes(colnames ...string) ([]int, error) {
	indexes := make([]int, len(colnames))
	for i, colname := range colnames {
		index := t.Index(colname)
		if index < 0 {
			return nil, errors.New("column " + colname + " not found in %sTable")
		}
		indexes[i] = index
	}
	return indexes, nil
}

`

// generate method def for ({struct-name})TableType.Indexes
func genIndexesMethod(s *Struct) string {
	return fmt.Sprintf(indexesMethodFmt, s.Name, s.Name, s.Name)
}

const aliasMethodFmt = `
// Alias aliases column names as hex-encoded indexes, for faster look-ups during
// decoding. If no column names are provided, all columns will be aliased, in
// which case AliasAll may be a faster alternative.
func (t *%sTableType) Alias(colnames ...string) ([]string, error) {
	aliases := []string{}
	// If no columns are specified, alias all columns:
	if len(colnames) == 0 {
		return %sTable.Aliases[:%d], nil
	}
	indexes, err := %sTable.Indexes(colnames...)
	if err != nil {
		return nil, err
	}
	for _, index := range indexes {
		aliases = append(aliases, %sTable.Aliases[index])
	}
	return aliases, nil
}

`

// generate method def for ({struct-name})TableType.Alias
func genAliasMethod(s *Struct) string {
	return fmt.Sprintf(aliasMethodFmt, s.Name, s.Name, len(s.Columns), s.Name, s.Name)
}

// generate method def for ({struct-name})TableType.AliasAll
func genAliasAllMethod(s *Struct) string {
	out := "// AliasAll aliases column names as hex-encoded indexes, for faster look-ups\n"
	out += "// during decoding\n"
	out += fmt.Sprintf("func (t *%sTableType) AliasAll() string {\n", s.Name)
	out += "return \""

	lastIdx := len(s.Columns) - 1
	for i, c := range s.Columns {
		// 256 columns are supported, for now:
		hexIdx := hex.EncodeToString([]byte{byte(i)})
		if len(hexIdx) == 1 {
			hexIdx = "0" + hexIdx
		}
		shortName := "__" + hexIdx
		out += fmt.Sprintf("%s as %s::%s", c.Name, shortName, c.Type)
		if i != lastIdx {
			out += ", "
		}
	}

	return out + "\"\n}\n\n"
}

// generate var def for {struct-name}Table
func genTable(s *Struct) (string, error) {
	out := fmt.Sprintf("// %sTable describes the table corresponding with type %s\n", s.Name, s.Name)
	out += fmt.Sprintf("var %sTable = %sTableType{\n", s.Name, s.Name)
	// include ordered list of param-encoder funcs:
	encoders, err := genEncoderArray(s)
	if err != nil {
		return "", err
	}
	out += encoders
	// include ordered list of column-decoder funcs:
	decoders, err := genColDecoderArray(s)
	if err != nil {
		return "", err
	}
	out += decoders
	// include ordered list of column names:
	out += genColNameArray(s)
	// include ordered list of column types:
	out += genColTypeArray(s)
	// include ordered list of column aliases:
	out += genAliasArray(s)
	// include ordered list of column format codes:
	out += genFormatArray(s)
	// include ordered list of column oids:
	out += genOidArray(s)

	return out + "}\n\n", nil
}

// include ordered list of param-encoder funcs (see genTable)
func genEncoderArray(s *Struct) (string, error) {
	out := fmt.Sprintf("UnboundEncoders: [%d]func(*%s) pgx.Encoder {\n", len(s.Columns), s.Name)
	for _, c := range s.Columns {
		f := c.StructField
		op := c.EncodeOp
		if op == Op(0) && c.Type != "json" {
			return "", fmt.Errorf("no column encoder available for field: %s.%s (coltype=%s, fieldtype=%s)", s.Name, f.Name, c.Type, f.Type)
		}
		dtName := DataTypeNames[c.Type]
		if dtName == "" {
			return "", fmt.Errorf("no column oid available for field: %s.%s (coltype=%s, fieldtype=%s)", s.Name, f.Name, c.Type, f.Type)
		}

		out += fmt.Sprintf("// Encode v.%s as %s\n", f.Name, c.Type)
		out += fmt.Sprintf("func(v *%s) pgx.Encoder {\n", s.Name)
		switch {
		default:
			if c.Type != "json" {
				var castPrefix, castSuffix string
				if op.MaskCast() != Op(0) {
					castPrefix, castSuffix = op.FormatCast()+"(", ")"
				}
				deref := ""
				if op.DerefPass() {
					deref = "*"
				}
				out += fmt.Sprintf("return pgtypes.%sEncoder(%s%sv.%s%s)\n", dtName, castPrefix, deref, f.Name, castSuffix)
			} else {
				switch f.Type {
				case "string", "*string":
					deref := ""
					if f.Type[0] == '*' {
						deref = "*"
					}
					out += fmt.Sprintf("return pgtypes.JSONEncoderString(%sv.%s)\n", deref, f.Name)
				case "[]byte", "*[]byte":
					deref := ""
					if f.Type[0] == '*' {
						deref = "*"
					}
					out += fmt.Sprintf("return pgtypes.JSONEncoderBytes(%sv.%s)\n", deref, f.Name)
				default:
					out += fmt.Sprintf("return pgtypes.JSONEncoder(v.%s)\n", f.Name)
				}
			}
		case op.CustomEncode():
			out += fmt.Sprintf("return v.%s\n", f.Name)
		case op.HstoreMapEncode():
			deref := ""
			if op.DerefPass() {
				deref = "*"
			}
			out += fmt.Sprintf("h := pgx.Hstore(%sv.%s)\n", deref, f.Name)
			// hstore oid varies, set it to 0 as a sentinel value:
			out += "return pgtypes.HstoreEncoder(h)\n"
		case op.UuidStringEncode():
			deref := ""
			if op.DerefPass() {
				deref = "*"
			}
			out += fmt.Sprintf("return pgtypes.UUIDEncoderString(%sv.%s)\n", deref, f.Name)
		}
		out += "},\n"
	}
	return out + "},\n", nil
}

// include ordered list of column-decoder funcs (see genTable)
func genColDecoderArray(s *Struct) (string, error) {
	count := len(s.Columns)
	out := fmt.Sprintf("Decoders: [%d]func(*%s, *pgx.ValueReader) error{\n", count, s.Name)
	for _, c := range s.Columns {
		decoder, err := genColumnDecoder(s, &c)
		if err != nil {
			return "", err
		}
		out += decoder
	}
	return out + "},\n", nil
}

// generate column-decoder func (see genColDecoderArray)
func genColumnDecoder(s *Struct, c *Column) (string, error) {
	f := c.StructField
	coltype := c.Type
	op := c.DecodeOp
	if op == Op(0) && c.Type != "json" {
		return "", fmt.Errorf("no column decoder available for field: %s.%s (coltype=%s, fieldtype=%s)", s.Name, f.Name, c.Type, f.Type)
	}
	dtName := DataTypeNames[coltype]
	if dtName == "" {
		return "", fmt.Errorf("no column oid available for field: %s.%s (coltype=%s, fieldtype=%s)", s.Name, f.Name, c.Type, f.Type)
	}
	// TODO(wd): check overflow, when necessary
	out := fmt.Sprintf("// Decode column %s::%s into (*%s).%s\n", c.Name, coltype, s.Name, f.Name)
	out += fmt.Sprintf("func(v *%s, vr *pgx.ValueReader) error {\n", s.Name)

	switch {
	case op.CustomScan():
		out += fmt.Sprintf("return v.%s.Scan(vr)\n", f.Name)
	case op.HstoreMapDecode():
		deref := ""
		if op.PtrAssign() {
			deref = "*"
		}
		out += fmt.Sprintf("h := pgx.Hstore(%sv.%s)\n", deref, f.Name)
		out += "return h.Scan(vr)\n"
	case op.UuidDecode():
		deref := ""
		if op.PtrAssign() {
			deref = "*"
		}
		out += "b := vr.ReadBytes(vr.ReadInt32())\n"
		out += "if vr.Err() != nil {\nreturn vr.Err()\n}\n"
		out += "if len(b) != 16 { return errors.New(\"invalid length for uuid (should be 16)\")\n}\n"
		out += "u, err := uuid.FromBytes(b)\n"
		out += "if err != nil {\nreturn err\n}\n"
		out += fmt.Sprintf("%sv.%s = u", deref, f.Name)
		if op.UuidStringDecode() {
			out += ".String()"
		}
		out += "\nreturn nil\n"
	default:
		if c.Type == "json" {
			switch f.Type {
			case "string", "*string":
				out += "s := vr.ReadString(vr.ReadInt32())\n"
				out += "if vr.Err() != nil {\nreturn vr.Err()\n}\n"
				deref := ""
				if f.Type[0] == '*' {
					deref = "*"
				}
				out += fmt.Sprintf("%sv.%s = s\n", deref, f.Name)
				out += "return nil\n"
			case "[]byte", "*[]byte":
				out += "b := vr.ReadBytes(vr.ReadInt32())\n"
				out += "if vr.Err() != nil {\nreturn vr.Err()\n}\n"
				deref := ""
				if f.Type[0] == '*' {
					deref = "*"
				}
				out += fmt.Sprintf("%sv.%s = b\n", deref, f.Name)
				out += "return nil\n"
			default:
				out += "b := vr.ReadBytes(vr.ReadInt32())\n"
				out += "if vr.Err() != nil {\nreturn vr.Err()\n}\n"
				takeAddr := ""
				if f.Type[0] != '*' {
					takeAddr = "&"
				}
				out += fmt.Sprintf("return json.Unmarshal(b, %sv.%s)", takeAddr, f.Name)
			}
		} else {
			var prefix, suffix string
			if op.MaskCast() != Op(0) {
				prefix, suffix = op.FormatCast()+"(", ")"
			}
			out += fmt.Sprintf("x := %svr.Decode%s()%s\n", prefix, dtName, suffix)
			out += "if vr.Err() != nil {\nreturn vr.Err()\n}\n"
			deref := ""
			if op.PtrAssign() {
				deref = "*"
			}
			out += fmt.Sprintf("%sv.%s = x\n", deref, f.Name)
			out += "return nil\n"
		}
	}
	out += "},\n"

	return out, nil
}

// include ordered list of column names (see genTable)
func genColNameArray(s *Struct) string {
	out := fmt.Sprintf("Names: [%d]string{\n", len(s.Columns))
	for _, c := range s.Columns {
		out += fmt.Sprintf("\"%s\",\n", c.Name)
	}
	return out + "},\n"
}

// include ordered list of column types (see genTable)
func genColTypeArray(s *Struct) string {
	out := fmt.Sprintf("Types: [%d]string{\n", len(s.Columns))
	for _, c := range s.Columns {
		out += fmt.Sprintf("\"%s\",\n", c.Type)
	}
	return out + "},\n"
}

// include ordered list of column aliases (see genTable)
func genAliasArray(s *Struct) string {
	out := "// Aliases contains an ordered list of column names aliased as hex-encoded\n"
	out += "// indexes, for faster look-ups during decoding\n"
	out += fmt.Sprintf("Aliases: [%d]string{\n", len(s.Columns))
	for i, col := range s.Columns {
		// 256 columns are supported, for now:
		hexIdx := hex.EncodeToString([]byte{byte(i)})
		if len(hexIdx) == 1 {
			hexIdx = "0" + hexIdx
		}
		shortName := "__" + hexIdx
		out += fmt.Sprintf("\"%s as %s::%s\",\n", col.Name, shortName, col.Type)
	}
	return out + "},\n"
}

// include ordered list of column oids (see genTable)
func genOidArray(s *Struct) string {
	out := fmt.Sprintf("Oids: [%d]pgx.Oid{\n", len(s.Columns))
	for _, c := range s.Columns {
		switch c.Type {
		case "hstore":
			// hstore oid varies, set it to 0 as a sentinel value:
			out += "pgx.Oid(0),\n"
		case "json":
			out += fmt.Sprintf("pgx.Oid(%d),\n", JSONOid)
		case "uuid":
			out += fmt.Sprintf("pgx.Oid(%d),\n", UUIDOid)
		default:
			out += fmt.Sprintf("pgx.%sOid,\n", DataTypeNames[c.Type])
		}
	}
	return out + "},\n"
}

// include ordered list of column format codes (text=0, binary=1) --  (see genTable)
func genFormatArray(s *Struct) string {
	out := fmt.Sprintf("Formats: [%d]int{", len(s.Columns))
	for i, c := range s.Columns {
		if BinaryDataTypes[DataTypeNames[c.Type]] {
			out += "1"
		} else {
			out += "0"
		}
		if i != len(s.Columns)-1 {
			out += ", "
		}
	}
	return out + "},\n"
}

const rowDecoderFmt = `
// DecodeRow decodes a single row/result from r into v.
// If an error is returned, the caller should call Rows.Close()
func (v *%s) DecodeRow(r *pgx.Rows) error {
	for _ = range r.FieldDescriptions() {
		vr, ok := r.NextColumn()
		if !ok {
			if vr != nil && vr.Err() != nil {
				return vr.Err()
			}
			break
		}
		colname := vr.Type().Name

		// Fast path (aliased columns):
		if len(colname) == 4 && colname[:2] == "__" {
			b, err := hex.DecodeString(colname[2:4])
			if err != nil {
				return err
			}
			index := int(b[0])
			if index < 0 || index > len(%sTable.Decoders) - 1 {
				return errors.New("column decoder index out of range")
			}
			dec := %sTable.Decoders[index]
			if err = dec(v, vr); err != nil {
				return err
			}
			continue
		}
		
		// Slow path:
		index := %sTable.Index(colname)
		if index < 0 {
			return errors.New("column decoder for " + colname + " not found in %sTable")
		}
		if err := %sTable.Decoders[index](v, vr); err != nil {
			return err
		}
	}
	return nil
}

`

// generate method def for {struct-name}.DecodeRow
func genRowDecoder(s *Struct) string {
	return fmt.Sprintf(rowDecoderFmt, s.Name, s.Name, s.Name, s.Name, s.Name, s.Name)
}

const paramsEncoderFmt = `
// %sParamsEncoder binds query/statement parameters from a value
// of type %s
type %sParamsEncoder struct {
	Indexes       []int
}

`

// generate type def for {struct-name}ParamsEncoder struct
func genParamsEncoderType(s *Struct) string {
	return fmt.Sprintf(paramsEncoderFmt, s.Name, s.Name, s.Name)
}

const newEncoderFmt = `
// Encoder creates an unbound instance of type %sParamsEncoder
// for the columns/fields named by colnames
func (t *%sTableType) Encoder(colnames ...string) (*%sParamsEncoder, error) {
	indexes, err := %sTable.Indexes(colnames...)
	if err != nil {
		return nil, err
	}

	pe := &%sParamsEncoder{Indexes: indexes}
	return pe, nil
}

`

// generate method def for {struct-name}TableType.Encoder
func genEncoderCreator(s *Struct) string {
	return fmt.Sprintf(newEncoderFmt, s.Name, s.Name, s.Name, s.Name, s.Name)
}

const bindValFmt = `
// Bind binds query/statement parameter encoders from v
func (pe %sParamsEncoder) Bind(v *%s) ([]pgx.Encoder, error) {
	encoders := make([]pgx.Encoder, len(pe.Indexes))
	for i, index := range pe.Indexes {
		if index < 0 || index > len(%sTable.UnboundEncoders) {
			return nil, errors.New("column encoder index out of range")
		}
		encoders[i] = %sTable.UnboundEncoders[index](v)
	}
	return encoders, nil
}

`

// generate method def for {struct-name}ParamsEncoder.Bind
func genBindVal(s *Struct) string {
	return fmt.Sprintf(bindValFmt, s.Name, s.Name, s.Name, s.Name)
}
