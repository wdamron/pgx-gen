package pointz

// Generated by pgxgen (see example.txt)

import (
	"encoding/hex"
	"errors"

	"github.com/wdamron/pgx"
)

// PointTableType is the type of PointTable, which describes the table
// corresponding with type Point
type PointTableType struct {
	// Encoders can be used to encode a single param value from type Point
	// into a write buffer, as part of a raw query
	Encoders [4]func(*Point, *pgx.WriteBuf) error
	// Decoders can be used to decode a single column value from a
	// pgx.ValueReader into type Point
	Decoders [4]func(*Point, *pgx.ValueReader) error
	// Names contains an ordered list of column names
	Names [4]string
	// Types contains an ordered list of column types
	Types [4]string
	// Aliases contains an ordered list of column names aliased as hex-encoded
	// indexes, for faster look-ups during decoding
	Aliases [4]string
	// Formats contains an ordered list of column format codes (text=0, binary=1)
	Formats [4]int
	// Oids contains an ordered list of column oid codes (corresponding with
	// Postgres types)
	Oids [4]pgx.Oid
}

// PointTable describes the table corresponding with type Point
var PointTable = PointTableType{
	Encoders: [4]func(*Point, *pgx.WriteBuf) error{
		// Encode (*Point).X as []varchar
		func(v *Point, wbuf *pgx.WriteBuf) error {
			wbuf.EncodeVarcharArray(v.X)
			return nil
		},
		// Encode (*Point).Y as int4
		func(v *Point, wbuf *pgx.WriteBuf) error {
			wbuf.EncodeInt4(int32(*v.Y))
			return nil
		},
		// Encode (*Point).Z as int4
		func(v *Point, wbuf *pgx.WriteBuf) error {
			v.Z.Encode(wbuf, pgx.Int4Oid)
			return nil
		},
		// Encode (*Point).H as hstore
		func(v *Point, wbuf *pgx.WriteBuf) error {
			v.H.Encode(wbuf, pgx.Oid(0))
			return nil
		},
	},
	Decoders: [4]func(*Point, *pgx.ValueReader) error{
		// Decode column x::[]varchar into (*Point).X
		func(v *Point, vr *pgx.ValueReader) error {
			x := vr.DecodeVarcharArray()
			if vr.Err() != nil {
				return vr.Err()
			}
			v.X = x
			return nil
		},
		// Decode column y::int4 into (*Point).Y
		func(v *Point, vr *pgx.ValueReader) error {
			x := int64(vr.DecodeInt4())
			if vr.Err() != nil {
				return vr.Err()
			}
			*v.Y = x
			return nil
		},
		// Decode column z::int4 into (*Point).Z
		func(v *Point, vr *pgx.ValueReader) error {
			if err := v.Z.Scan(vr); err != nil {
				return err
			}
			return nil
		},
		// Decode column h::hstore into (*Point).H
		func(v *Point, vr *pgx.ValueReader) error {
			if err := v.H.Scan(vr); err != nil {
				return err
			}
			return nil
		},
	},
	Names: [4]string{
		"x",
		"y",
		"z",
		"h",
	},
	Types: [4]string{
		"[]varchar",
		"int4",
		"int4",
		"hstore",
	},
	// Aliases contains an ordered list of column names aliased as hex-encoded
	// indexes, for faster look-ups during decoding
	Aliases: [4]string{
		"x as __00::[]varchar",
		"y as __01::int4",
		"z as __02::int4",
		"h as __03::hstore",
	},
	Formats: [4]int{1, 1, 1, 0},
	Oids: [4]pgx.Oid{
		pgx.VarcharArrayOid,
		pgx.Int4Oid,
		pgx.Int4Oid,
		pgx.Oid(0),
	},
}

// Index returns the index of the column in PointTable with the given name.
// If no matching column is found, the returned index will be -1.
func (t *PointTableType) Index(colname string) int {
	switch colname {
	case "x":
		return 0
	case "y":
		return 1
	case "z":
		return 2
	case "h":
		return 3
	}
	return -1
}

// Indexes returns a slice of indexes of the given columns in PointTable
// with the given name. If any of the columns are not found, an error will be
// returned and the returned slice of indexes will be nil.
func (t *PointTableType) Indexes(colnames ...string) ([]int, error) {
	indexes := make([]int, len(colnames))
	for i, colname := range colnames {
		index := t.Index(colname)
		if index < 0 {
			return nil, errors.New("column " + colname + " not found in PointTable")
		}
		indexes[i] = index
	}
	return indexes, nil
}

// Aliases aliases column names as hex-encoded indexes, for faster look-ups during
// decoding. If no column names are provided, all columns will be aliased, in
// which case AliasAll may be a faster alternative.
func (t *PointTableType) Aliases(colnames ...string) ([]string, error) {
	aliases := []string{}
	// If no columns are specified, alias all columns:
	if len(cols) == 0 {
		return PointTable.Aliases[:4], nil
	}
	indexes, err := PointTable.Indexes(colnames...)
	if err != nil {
		return nil, err
	}
	for _, index := range indexes {
		aliases = append(aliases, PointTable.Aliases[index])
	}
	return aliases, nil
}

// AliasAll aliases column names as hex-encoded indexes, for faster look-ups
// during decoding
func (t *PointTableType) AliasAll() string {
	return "x as __00::[]varchar, y as __01::int4, z as __02::int4, h as __03::hstore"
}

// DecodeRow decodes a SQL row into type Point.
// If an error is returned, the caller should call Rows.Close()
func (v *Point) DecodeRow(r *pgx.Rows) error {
	for _ = range r.FieldDescriptions() {
		vr, ok := r.NextColumn()
		if !ok {
			if vr != nil && vr.Err() {
				return vr.Err()
			}
			break
		}
		colname := vr.Type().Name

		// Fast path (aliased columns):
		if len(colname) == 4 && colname[:2] == "__" {
			b, err := hex.DecodeString(colname[2:4])
			if err != nil {
				return err
			}
			index := int(b[0])
			if index < 0 || index > len(PointTable.Decoders)-1 {
				return errors.New("column decoder index out of range")
			}
			dec := PointTable.Decoders[index]
			if err = dec(v, vr); err != nil {
				return err
			}
			continue
		}

		// Slow path:
		index := PointTable.Index(colname)
		if index < 0 {
			return errors.New("column decoder for " + colname + " not found in PointTable")
		}
		if err := PointTable.Decoders[index](v, vr); err != nil {
			return err
		}
	}
	return nil
}

// PointParamsEncoder encodes parameter formats and values for a prepared statement
// to a buffer, and implements pgx.ParamsEncoder
type PointParamsEncoder struct {
	Indexes       []int
	Formats       []int
	ValueEncoders []func(v *Point, wbuf *pgx.WriteBuf)
	v             *Point
}

// Encoder creates an unbound instance of type PointParamsEncoder
// for the columns/fields named by colnames
func (t *PointTableType) Encoder(colnames ...string) (*PointParamsEncoder, error) {
	formats := make([]int, len(colnames))
	encoders := make([]func(*Point, *pgx.WriteBuf), len(colnames))

	indexes, err := PointTable.Indexes(colnames...)
	if err != nil {
		return nil, err
	}
	for i, index := range indexes {
		formats[i] = PointTable.Formats[index]
		encoders[i] = PointTable.Encoders[index]
	}

	pe := &PointParamsEncoder{
		Indexes:       indexes,
		Formats:       formats,
		ValueEncoders: encoders,
	}
	return pe, nil
}

// Bind binds value v to pe, returning a pgx.ParamsEncoder for use within raw queries
func (pe PointParamsEncoder) Bind(v *Point) pgx.ParamsEncoder {
	return &PointParamsEncoder{
		Indexes:       pe.Indexes,
		Formats:       pe.Formats,
		ValueEncoders: pe.ValueEncoders,
		v:             v,
	}
}

// EncodeParamFormats encodes param formats into wbuf, as part of a raw query
// (PointParamsEncoder should implement pgx.ParamsEncoder)
func (pe *PointParamsEncoder) EncodeParamFormats(ps *pgx.PreparedStatement, wbuf *pgx.WriteBuf) error {
	if len(ps.ParameterOids) != len(pe.Formats) {
		return errors.New("param count of encoder and prepared statement do not match")
	}
	for i, oid := range ps.ParameterOids {
		foundOid := PointTable.Oids[pe.Indexes[i]]
		if oid != foundOid && foundOid != pgx.Oid(0) {
			return errors.New("param oids of encoder and prepared statement do not match")
		}
		wbuf.WriteInt16(int16(pe.Formats[i]))
	}
	return nil
}

// EncodeParams encodes the param values into wbuf, as part of a raw query
// (PointParamsEncoder should implement pgx.ParamsEncoder)
func (pe *PointParamsEncoder) EncodeParams(ps *pgx.PreparedStatement, wbuf *pgx.WriteBuf) error {
	for _, enc := range pe.ValueEncoders {
		enc(pe.v, wbuf)
	}
	return nil
}
