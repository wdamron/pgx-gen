package pointz

// Generated by pgxgen (see example.txt)

import (
	"encoding/hex"
	"errors"

	"github.com/wdamron/pgx"
)

// PointColumnDecoder funcs can be used to decode a single column value
// from a pgx.ValueReader into a Point
type PointColumnDecoder func(*Point, *pgx.ValueReader) error

// PointTableType is the type of PointTable, which describes the table
// corresponding with type Point
type PointTableType struct {
	// Decoders can be used to decode a single column value from a
	// pgx.ValueReader into a Point
	Decoders    [2]PointColumnDecoder
	ColumnNames [2]string
	// Aliases contains an ordered list of column names aliased as hex-encoded
	// indexes, for faster look-ups during decoding
	Aliases [2]string
}

// Alias aliases column names as hex-encoded indexes, for faster
// look-ups during decoding.
// If no column names are provided, all columns will be aliased,
// in which case AliasAll may be a faster alternative.
func (t *PointTableType) Alias(cols ...string) ([]string, error) {
	aliases := []string{}
	// If no columns are specified, alias all columns:
	if len(cols) == 0 {
		return PointTable.Aliases[:2], nil
	}
	for _, name := range cols {
		switch name {
		case "x":
			aliases = append(aliases, "x as __00::[]varchar")
		case "y":
			aliases = append(aliases, "y as __01::int4")
		default:
			return nil, errors.New("column " + name + " not found in type Point")
		}
	}
	return aliases, nil
}

// AliasAll aliases column names as hex-encoded indexes, for faster
// look-ups during decoding
func (t *PointTableType) AliasAll() string {
	return "x as __00::[]varchar, y as __01::int4"
}

// PointTable describes the table corresponding with type Point
var PointTable = PointTableType{
	Decoders: [2]PointColumnDecoder{
		// Decode column x::[]varchar into (*Point).X
		func(v *Point, vr *pgx.ValueReader) error {
			if vr.Type().DataType != pgx.VarcharArrayOid {
				return errors.New("mismatched data types")
			}
			x := vr.DecodeVarcharArray()
			if vr.Err() != nil {
				return vr.Err()
			}
			v.X = x
			return nil
		},
		// Decode column y::int4 into (*Point).Y
		func(v *Point, vr *pgx.ValueReader) error {
			if vr.Type().DataType != pgx.Int4Oid {
				return errors.New("mismatched data types")
			}
			x := int64(vr.DecodeInt4())
			if vr.Err() != nil {
				return vr.Err()
			}
			*v.Y = x
			return nil
		},
	},
	ColumnNames: [2]string{
		"x",
		"y",
	},
	// Aliases contains an ordered list of column names aliased as hex-encoded
	// indexes, for faster look-ups during decoding
	Aliases: [2]string{
		"x as __00::[]varchar",
		"y as __01::int4",
	},
}

// DecodeRow decodes a SQL row into a Point.
// If an error is returned, the caller should call Rows.Close()
func (v *Point) DecodeRow(r *pgx.Rows) error {
	for _ = range r.FieldDescriptions() {
		vr, ok := r.NextColumn()
		if !ok {
			if vr != nil && vr.Err() {
				return vr.Err()
			}
			break
		}
		colname := vr.Type().Name

		// Fast path (aliased columns):
		if len(colname) == 4 && colname[:2] == "__" {
			b, err := hex.DecodeString(colname[2:4])
			if err != nil {
				return err
			}
			index := int(b[0])
			if index < 0 || index > 1 {
				return errors.New("column-decoder index out of range")
			}
			dec := PointTable.Decoders[index]
			if err = dec(v, vr); err != nil {
				return err
			}
			continue
		}

		// Slow path:
		var dec PointColumnDecoder
		switch colname {
		case "x":
			dec = PointTable.Decoders[0]
		case "y":
			dec = PointTable.Decoders[1]
		default:
			return errors.New("unknown column name: " + colname)
		}
		if err := dec(v, vr); err != nil {
			return err
		}
	}
	return nil
}
